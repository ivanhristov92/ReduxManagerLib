<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
Redux and React are a wildly popular combination, and for a good reason - suitable for all tasks at hand, keeping your hands untangled when you need to add in or change existing functionality. Manageable state, straightforward data flow, good separation of concerns, functional programming practices - all great! But not all is roses when the deadline is closing in and you're still doing some basic data piping.

In the interest of saving time different tools have emerged attempting to facilitate faster development. From simple abstractions, to code generators, to a variety of more or less complex systems handling some of your redux for you. Code generators could be useful here and there, but they leave a lot of code behind, which is easily broken by an uncareful hand and quickly looses gracefulness. Simple abstractions simply are rarely enough and complex systems - opinionated. Trial and error of different approaches and tools  have lead to a set of core concepts for managing redux that allow for quick product iterations, without losing flexibility in the long term.

So, what are the main problems that may cause an ambitious green project to stray and into the swamps before it even takes off. The first factor is indirection. Not knowing where to each part of the code belongs. Is it in the action creator, the side effects layer, the REST API agent, middleware, etc. Then comes inconsistency - you write it once here, once - there, just to get it to work initially, then it lives there. Finally - the sheer size of the code. Luckily, with a few proper convention rules in place some of this frustration disappears. But consistency and leaner code base can only be achieved with reasonable abstractions - and they must be extendable to be of any service in the first place.
</body>
</html>