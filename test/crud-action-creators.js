// c. Action Creators – ModelName.(verb + State) : MyModel.(create | createSuccess)()
//     = verbs – create, read, update, delete
//     = states – Success, Failure
// d. State name – model name
// e. Selectors – all selectors begin with “get”
// = verbs – get (optional getOne), getIds, getCount

import actionCreatorsFactory from "../crud-action-creators";
var assert = require("assert");
var sinon = require("sinon");
import * as _ from "ramda";
import actionTypesFactory from "../crud-action-types";

describe("CRUD Action Creators", () => {
  describe("The module must expose a factory function, that creates the action creators for a model", function() {
    it("The module should default export a function", () => {
      assert.equal(typeof actionCreatorsFactory, "function");
    });
  });

  describe("The module factory function must require 'actionTypes' and 'restApi' as arguments", function() {
    it("'actionTypes' must be required", () => {
      assert.throws(function() {
        actionCreatorsFactory(null, {}, {});
      });
    });

    it("'restApi' must be required", () => {
      assert.throws(function() {
        actionCreatorsFactory({}, null, {});
      });
    });
  });

  describe("The factory function must return an object with the action creators", function() {
    it("returns an object", () => {
      let actionCreators = actionCreatorsFactory({}, {}, {});
      assert.equal(typeof actionCreators, "object");
    });

    it("returns a non-empty object", () => {
      let actionCreators = actionCreatorsFactory({}, {}, {});
      assert.equal(_.isEmpty(actionCreators), false);
    });

    describe("The factory function must return an object with all non-stateful action creators", function() {
      const propNotFound = " property was not found";

      ["create", "read", "update", "delete"].forEach(crudAct => {
        it(`returns an object with a '${crudAct}' function`, () => {
          let actionCreators = actionCreatorsFactory({}, {}, {});
          assert.equal(
            _.has(crudAct, actionCreators),
            true,
            `${crudAct} ${propNotFound}`
          );
          assert.equal(typeof actionCreators[crudAct], "function");
        });
      });
    });
  });

  describe("[THUNK-SPECIFIC] All crud thunks must dispatch an initial action, and a result action", function() {
    // {
    //     type: ModuleName/SOME_ACTION (+ STATE),
    //         error: null | Object,
    //     payload? : any,
    //     meta: {
    // @@autogenerated: boolean,
    //         module: some string,
    //         action: SOME_ACTION,
    //         state: SUCCESS/ERROR
    // }
    //
    // }

    const CRUD = ["create", "read", "update"];

    describe("[THUNK-SPECIFIC] All crud thunks dispatch an initial action", function() {
      CRUD.forEach(crudAct => {
        it(`"${crudAct}" should call store.dispatch at least once`, () => {
          // 'dispatch' has been called at least once

          let store = { dispatch() {} };
          const restApi = { create: () => Promise.resolve() };
          const actionCreators = actionCreatorsFactory({}, restApi, store);

          sinon.spy(store, "dispatch");
          const thunkFunction = actionCreators[crudAct]();
          thunkFunction(store.dispatch);

          const dispatchCall = store.dispatch.getCall(0);
          assert.notEqual(dispatchCall, null);
        });

        it(`"${crudAct}" should call store.dispatch firstly with a "bare" action type - without any state`, () => {
          // 'dispatch' has been called at least once

          let store = { dispatch() {} };
          const restApi = { create: () => Promise.resolve() };
          const actionTypes = actionTypesFactory("MyModel");
          const actionCreators = actionCreatorsFactory(
            actionTypes,
            restApi,
            store
          );
          const expectedActionType = actionTypes[crudAct.toUpperCase()];

          sinon.spy(store, "dispatch");
          const thunkFunction = actionCreators[crudAct]();
          thunkFunction(store.dispatch);

          const dispatchCall = store.dispatch.getCall(0);
          const dispatchedAction = dispatchCall.args[0];
          assert.equal(dispatchedAction.type, expectedActionType);
        });
      });
    });

    describe("[THUNK-SPECIFIC] All crud thunks should dispatch a 'success' type action, when the promise resolves", function() {
      CRUD.forEach(crudAct => {
        it(`"${crudAct}" should call store.dispatch at least 2 times`, done => {
          // 'dispatch' has been called at least once

          let store = { dispatch() {} };
          const restApi = { create: () => Promise.resolve() };
          const actionCreators = actionCreatorsFactory({}, restApi, store);

          sinon.spy(store, "dispatch");
          const thunkFunction = actionCreators[crudAct]();

          thunkFunction(store.dispatch).then(function() {
            const dispatchCall = store.dispatch.getCall(1);

            assert.notEqual(dispatchCall, null);
            done();
          });
        });

        it(`"${crudAct}" should call store.dispatch with a 'success' action type the second time, when the promise resolves`, done => {
          let store = { dispatch() {} };
          const restApi = { create: () => Promise.resolve() };
          const actionTypes = actionTypesFactory("MyModel");
          const actionCreators = actionCreatorsFactory(
            actionTypes,
            restApi,
            store
          );
          const expectedActionType =
            actionTypes[crudAct.toUpperCase() + "__SUCCESS"];

          sinon.spy(store, "dispatch");
          const thunkFunction = actionCreators[crudAct]();

          thunkFunction(store.dispatch).then(function() {
            const dispatchCall = store.dispatch.getCall(1);
            const dispatchedAction = dispatchCall.args[0];
            assert.notEqual(typeof dispatchedAction.type, "undefined");
            assert.equal(dispatchedAction.type, expectedActionType);
            done();
          });
        });

        it(`"${crudAct}" should call store.dispatch with a 'failure' action type the second time, when the promise rejects`, done => {
          let store = { dispatch() {} };
          const restApi = { create: () => Promise.reject() };
          const actionTypes = actionTypesFactory("MyModel");
          const actionCreators = actionCreatorsFactory(
            actionTypes,
            restApi,
            store
          );
          const expectedActionType =
            actionTypes[crudAct.toUpperCase() + "__FAILURE"];

          sinon.spy(store, "dispatch");
          const thunkFunction = actionCreators[crudAct]();

          thunkFunction(store.dispatch).then(() => {
            const dispatchCall = store.dispatch.getCall(1);
            const dispatchedAction = dispatchCall.args[0];
            assert.notEqual(typeof dispatchedAction.type, "undefined");
            assert.equal(dispatchedAction.type, expectedActionType);
            done();
          });
        });
      });
    });
  });
});
