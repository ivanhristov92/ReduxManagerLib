Redux Manager Library




Concept

Autogenerate boilerplate objects and functions in run-time to manage database models.
Expose a standardized API for working with these models – selectors, actions.
Implement a way for overriding or adding additional features while adhering to the same standard.
Optimize for  bootstrapping green projects over extending existing ones.


Goals

1. Keep it as simple as possible. Start with the smallest defaults and provide ways for extending with more complex set-ups.
2. Design the system to be very lean, without any coupling with the data inside it, to allow seamless interoperability with any other system.
2.1 Don’t depend on libraries. Use an interface (for ramda/underscore/lodash for example).

Standards

1. Normalization of data
Without normalization of the data, the selectors need to be custom made, the reducers too – for each model, as we will not know the structure of the data beforehand.

2. Rest Calls
- Rest Api calls are executed inside functions, and arranged in a module, that the system can work with. There is going to be an interface and test suit to ensure that interface.
- The functions must return promises, as promises can be used inside observables and sagas – and are the simplest to work with.
- All resolved data returned by the rest api function must be in normalized form, for the system to be able to work with it.
- Error messages occurring in rest calls must come from in rejected promises only. If the need be, an adapter is implemented.

3. Naming
a. Models – any string (“ModelName”)
b. Action Types – ModelName/SOME_ACTION__STATE
= states – SUCCESS, FAILURE
c. Action Creators – ModelName.(verb + State) : MyModel.(create | createSuccess)()
= verbs – create, read, update, delete
= states – Success, Failure
d. State name – model name
e. Selectors – all selectors begin with “get”
= verbs – get (optional getOne), getIds, getCount

4. Actions – actions follow the flux standard (type, error and payload), and an additional meta information section, which is optional.

{
	type: ModuleName/SOME_ACTION (+ STATE),
	error: null | Object,
	payload? : any,
	meta: {
		@@autogenerated: boolean,
		module: some string,
		action: SOME_ACTION,
		state: SUCCESS/ERROR
	}

}

Crucial User Facing Interface

- for calling auto-generated crud model actions  - without their respective consecutive state actions.

- for getting bits of the state – selectors

- for working with auto-generated actions


- for implementing their own reducer (Should provide an option inherit the default reducer and extend it – seems simpler than extending the existing reducer, without completely overriding it – a new implementation is better than a mixture of an old one and a new one. Or a code generator? Could be both.)

- for implementing their own side effects layer(what will be the default side effects layer – the simplest one – redux-thunk)
= redux-observables
= redux-sagas

- for implementing their own selectors service (inherited first, code-generated second – in their core they should be the same logic, only the port should be a different adapter!)


- for creating their own standard-compliant actions and action creators

- for creating standard-compliant selectors

- a specification for implementing their own rest api connector




Overall Architecture

1. Default implementations for
a. Action Types
b. Action Creators – expose a method that gives crud-state action creators (thunks)
c. Reducer
d. Side Effects (redux-thunk)
e. Selectors

- Default implementations expose an extend method.

2. Custom Defaults/Custom Layer Implementations (that will be used as the new default when a new model is being created)
- they can extend default system layers (such as the side effects layer), or be completely independent of the defaults.
- they must expose an extend method, too.

3. Layers Configuration – here you provide the custom layer implementation that will serve as the system default for all models on their instantiation.

4. Model Configuration – passing configuration to the new model on its creation. Extending custom, or system built defaults for any of the layers happens here.


5. Tests
- for default and custom layer implementations (signatures, results, conventions) – the same test suit. If the user replaces a layer, they need to still adhere to the standards, to take advantage of this system in the first place. Otherwise, they would have to extend all the modules.


6 Model Proto
a. Action Types
b. CRUD Action Creators
c. Selectors




Runtime Sequence

1. Gather all dependencies (all are represented by interfaces inside the code logic)
- Action Types Layer
- Action Creators Layer
- Side Effects Layer
- Reducer Layer
- Selectors Layer


2. Initialize
- Action Types
- (thread 1) Action Creators → Side Effects | (thread 2) Reducer, Selectors

3. Give back the generated module

Development Stage 1

1. Default implementations for the layers
3. Layers Configuration – just keep it in mind
4. Model Configuration
5. Tests – make tests reusable for custom layer implementations
